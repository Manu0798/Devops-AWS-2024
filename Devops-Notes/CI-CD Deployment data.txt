# How to deploy application using CI/CD pipeline
-> You will create one ubuntu Ec2 instance with t2.large Instance type and 20Gb Size.
-> Thereafter you will login the ec2 server using mobxterm
-> You have to install Jenkins, Docker, SonarQube, maven, git, trivy and npm in the server using below commands
-> sudo apt-get update -y
-> mkdir scripts
-> cd scripts

# Install Jenkins and create the file using below and paste the script whichever file you have created

vi Jenkins.sh

sudo wget -O /usr/share/keyrings/jenkins-keyring.asc \
    https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
echo "deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc]" \
    https://pkg.jenkins.io/debian-stable binary/ | sudo tee \
    /etc/apt/sources.list.d/jenkins.list > /dev/null
sudo apt-get update
sudo apt-get install fontconfig openjdk-17-jre
sudo apt-get install jenkins -y

# Execute the below commands to run the script
sudo chmod +x Jenkins.sh
./Jenkins.sh
sudo cat /var/lib/jenkins/secrets/initialAdminPassword

# Install Docker and create the file using below and paste the script whichever file you have created

vi docker.sh

# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y
sudo chmod 666 /var/run/docker.sock

# Execute the below commands to run the script
sudo chmod +x docker.sh
./docker.sh


-> After install the docker you will execute the below commands for Docker Slave Configuration
sudo apt update
sudo apt install docker.io
sudo su - 
usermod -aG docker jenkins
usermod -aG docker ubuntu
systemctl restart docker


# # To install sonar execute below steps one by one [You may install SonarQube using commands or docker image]
sudo su -
apt install unzip
adduser sonarqube
sudo su - sonarqube
wget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-9.4.0.54424.zip
sudo unzip sonarqube-9.4.0.54424.zip
chmod -R 755 /home/sonarqube/sonarqube-9.4.0.54424
chown -R sonarqube:sonarqube /home/sonarqube/sonarqube-9.4.0.54424
cd sonarqube-9.4.0.54424/bin/linux-x86-64/
./sonar.sh start


# Install maven and create the file using below and paste the script whichever file you have created

vi maven.sh

sudo apt update
sudo apt install maven -y
mvn -version

# Execute the below commands to run the script
sudo chmod +x maven.sh
./maven.sh

# Install Git and create the file using below and paste the script whichever file you have created

vi git.sh

sudo apt update
sudo apt install git -y
git --version

# Execute the below commands to run the script
sudo chmod +x git.sh
./git.sh


# To install trivy execute below steps one by one

sudo apt-get install wget apt-transport-https gnupg lsb-release
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
sudo apt-get update
sudo apt-get install trivy
trivy --version

# To install NPM execute below steps one by one

# installs fnm (Fast Node Manager)
curl -fsSL https://fnm.vercel.app/install | bash

# activate fnm
source ~/.bashrc

# download and install Node.js
fnm use --install-if-missing 22

# verifies the right Node.js version is in the environment
node -v # should print `v22.7.0`

# verifies the right npm version is in the environment
npm -v # should print `10.8.2`


# After install the all the above tools, using publicIp and portnumber access the browser
-> PubilcIp:8080 -> To get Jenkins
-> PubilcIp:9000 -> To get Sonar-qube

-> After login the Jenkins and go to the manage Jenkins, Click Plugins and install the below Plugins

  EclipseTemurin  and JDK for java pupose
  Docker and Docker Pipeline
  Sonar-scanner
  Nodjs
  Dependency check
  Email-extension plugin

Note: If you want to install plugins manually from local, Go to the below website and search the plugin
https://plugins.jenkins.io/
click the releases and download the plugin, How to upload the plugin into jenkins
go to manage jenkins and click plugins and go to advance settings and choose the file and click deploy.
later go to the installed plugins and check wheather is it installed or not


-> You will restart the Jenkins after install the plugins

-> Go to manage Jenkins, click configuration tools and install below tools
  -> JDK-17  install automatically
  -> default, Git     install automatically
  -> sonar-scanner  install automatically
  -> Nodejs installations -> Give name, install automatically
  -> dependency check click install automatically and click github
  -> maven  install automatically
  -> Docker  install automatically

-> Later go the credentials and add the docker,sonar,git and email credentials
    Docker -> click username and password Give docker username,password and id
    sonar  -> Click secret text and give sonar token and keep some name in ID
    git    -> Click secret text and give token and ID
    git    -> Click username and password and give username and token
    email  -> Click username and password and give mail id and password [go gmail and click manage google account 
              Click security and search App password in search bar and click app password and give one name and create then you will get one password you save that password and give that password in above credentials]

-> You will restart the jenkins after complete the above steps

-> Click the manage jenkins, click system configuration and go SonarQube installations give name, sonaqube URL and click sonar token. 
-> Later you will configure email by pic in mobile
-> You will configure above details by video in ph
-> You will restart the jenkins after complete the above steps

Later you will try to run the jobs using below scripts

pipeline {
    agent {
    docker {
      image 'abhishekf5/maven-abhishek-docker-agent:v1'
      args '--user root -v /var/run/docker.sock:/var/run/docker.sock' // mount Docker socket to access the host's Docker daemon
    }
  }
    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/pipelie-cicd:${BUILD_NUMBER}"
        GIT_REPO_NAME = "tomat123"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Kubernets/deployment.yml"  // Adjust the path if necessary
    }
    
    stages {
        stage('GetCode') {
            steps {
                git branch: 'master', url: 'https://github.com/manoj7894/tomat123.git'
            }
        }

        stage('Build') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }

        stage('Login') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'Docker_id', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'
                }
            }
        }

        stage('Static Code Analysis') {
            environment {
                SONAR_URL = "http://13.233.28.18:9000"
            }
            steps {
                withCredentials([string(credentialsId: 'sonar_token', variable: 'SONAR_AUTH_TOKEN')]) {
                    sh '''
                        mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=$SONAR_URL
                    '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    def dockerImage = docker.image(DOCKER_IMAGE)
                    dockerImage.push() // Pushes the Docker image to the repository
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        // Configure Git
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        // Check out the repository
                        sh 'git checkout master'

                        // Display the current content of the deployment file for debugging
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        // Update the image tag in deployment.yml
                        sh '''
                            # Use sed to replace the image tag dynamically
                            sed -i "s|image: manoj3003/pipelie-cicd:[^[:space:]]*|image: manoj3003/pipelie-cicd:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        // Check for changes and commit if necessary
                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:master
                            fi
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            emailext (
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'varmapotthuri4@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                mimeType: 'text/html'
            )
        }
    }
}


# To delete previous docker images we will use below pipeline script
pipeline {
    agent {
    docker {
      image 'abhishekf5/maven-abhishek-docker-agent:v1'
      args '--user root -v /var/run/docker.sock:/var/run/docker.sock' // mount Docker socket to access the host's Docker daemon
    }
  }


    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/pipelie-cicd:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/pipelie-cicd:*"  // Pattern to match old images
        GIT_REPO_NAME = "tomat123"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Kubernets/deployment.yml"  // Adjust the path if necessary
    }

    stages {
        stage('Cleanup Old Docker Images') {
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    // Get the list of old images matching the pattern
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${OLD_IMAGE_TAG_PATTERN}'", returnStdout: true).trim()
                    
                    if (oldImages) {
                        oldImages.split('\n').each { image ->
                            if (image != DOCKER_IMAGE) {
                                echo "Attempting to remove old image ${image}"
                                sh """
                                    # Check if the image exists before trying to delete it
                                    if docker images -q ${image} > /dev/null 2>&1; then
                                        # Try to remove the image
                                        docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                    else
                                        echo 'Image ${image} does not exist.'
                                    fi
                                """
                            }
                        }
                    } else {
                        echo "No old images found matching pattern ${OLD_IMAGE_TAG_PATTERN}"
                    }
                }
            }
        }

        stage('GetCode') {
            steps {
                git branch: 'master', url: 'https://github.com/manoj7894/tomat123.git'
            }
        }

        stage('Build') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }

        stage('Login') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'Docker_id', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'
                }
            }
        }

        stage('Static Code Analysis') {
            environment {
                SONAR_URL = "http://13.233.28.18:9000"
            }
            steps {
                withCredentials([string(credentialsId: 'sonar_token', variable: 'SONAR_AUTH_TOKEN')]) {
                    sh '''
                        mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=$SONAR_URL
                    '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    def dockerImage = docker.image(DOCKER_IMAGE)
                    dockerImage.push() // Pushes the Docker image to the repository
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        // Configure Git
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        // Check out the repository
                        sh 'git checkout master'

                        // Display the current content of the deployment file for debugging
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        // Update the image tag in deployment.yml
                        sh '''
                            # Use sed to replace the image tag dynamically
                            sed -i "s|image: manoj3003/pipelie-cicd:[^[:space:]]*|image: manoj3003/pipelie-cicd:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        // Check for changes and commit if necessary
                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:master
                            fi
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            emailext (
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'varmapotthuri4@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                mimeType: 'text/html'
            )
        }
    }
}




# Do you want to deploy the job using agent any you have to use below script
pipeline {
    agent any


    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/pipelie-cicd:${BUILD_NUMBER}"
        GIT_REPO_NAME = "tomat123"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Kubernets/deployment.yml"  // Adjust the path if necessary
    }

    stages {
           stage('GetCode') {
            steps {
                git branch: 'master', url: 'https://github.com/manoj7894/tomat123.git'
            }
        }

        stage('Build') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }

        stage('Login') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'Docker_id', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'
                }
            }
        }

        stage('Static Code Analysis') {
            environment {
                SONAR_URL = "http://13.233.28.18:9000"
            }
            steps {
                withCredentials([string(credentialsId: 'sonar_token', variable: 'SONAR_AUTH_TOKEN')]) {
                    sh '''
                        mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=$SONAR_URL
                    '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    def dockerImage = docker.image(DOCKER_IMAGE)
                    dockerImage.push() // Pushes the Docker image to the repository
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        // Configure Git
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        // Check out the repository
                        sh 'git checkout master'

                        // Display the current content of the deployment file for debugging
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        // Update the image tag in deployment.yml
                        sh '''
                            # Use sed to replace the image tag dynamically
                            sed -i "s|image: manoj3003/pipelie-cicd:[^[:space:]]*|image: manoj3003/pipelie-cicd:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        // Check for changes and commit if necessary
                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:master
                            fi
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            emailext (
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'varmapotthuri4@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                mimeType: 'text/html'
            )
        }
    }
}


# To delete the previous docker images you should use below script


pipeline {
    agent any


    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/pipelie-cicd:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/pipelie-cicd:*"  // Pattern to match old images
        GIT_REPO_NAME = "tomat123"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Kubernets/deployment.yml"  // Adjust the path if necessary
    }

    stages {
        stage('Cleanup Old Docker Images') {
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    // Get the list of old images matching the pattern
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${OLD_IMAGE_TAG_PATTERN}'", returnStdout: true).trim()
                    
                    if (oldImages) {
                        oldImages.split('\n').each { image ->
                            if (image != DOCKER_IMAGE) {
                                echo "Attempting to remove old image ${image}"
                                sh """
                                    # Check if the image exists before trying to delete it
                                    if docker images -q ${image} > /dev/null 2>&1; then
                                        # Try to remove the image
                                        docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                    else
                                        echo 'Image ${image} does not exist.'
                                    fi
                                """
                            }
                        }
                    } else {
                        echo "No old images found matching pattern ${OLD_IMAGE_TAG_PATTERN}"
                    }
                }
            }
        }

        stage('GetCode') {
            steps {
                git branch: 'master', url: 'https://github.com/manoj7894/tomat123.git'
            }
        }

        stage('Build') {
            steps {
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }

        stage('Login') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'Docker_id', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'
                }
            }
        }

        stage('Static Code Analysis') {
            environment {
                SONAR_URL = "http://13.233.28.18:9000"
            }
            steps {
                withCredentials([string(credentialsId: 'sonar_token', variable: 'SONAR_AUTH_TOKEN')]) {
                    sh '''
                        mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=$SONAR_URL
                    '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    def dockerImage = docker.image(DOCKER_IMAGE)
                    dockerImage.push() // Pushes the Docker image to the repository
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        // Configure Git
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        // Check out the repository
                        sh 'git checkout master'

                        // Display the current content of the deployment file for debugging
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        // Update the image tag in deployment.yml
                        sh '''
                            # Use sed to replace the image tag dynamically
                            sed -i "s|image: manoj3003/pipelie-cicd:[^[:space:]]*|image: manoj3003/pipelie-cicd:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        // Check for changes and commit if necessary
                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:master
                            fi
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            emailext (
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'varmapotthuri4@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                mimeType: 'text/html'
            )
        }
    }
}

# Do you want to deploy the application with dependency check. you can use dependency check only in build applications
pipeline {
    agent any


    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/pipelie-cicd:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/pipelie-cicd:*"  // Pattern to match old images
        GIT_REPO_NAME = "tomat123"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Kubernets/deployment.yml"  // Adjust the path if necessary
    }

    stages {
        stage('Cleanup Old Docker Images') {
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    // Get the list of old images matching the pattern
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${OLD_IMAGE_TAG_PATTERN}'", returnStdout: true).trim()
                    
                    if (oldImages) {
                        oldImages.split('\n').each { image ->
                            if (image != DOCKER_IMAGE) {
                                echo "Attempting to remove old image ${image}"
                                sh """
                                    # Check if the image exists before trying to delete it
                                    if docker images -q ${image} > /dev/null 2>&1; then
                                        # Try to remove the image
                                        docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                    else
                                        echo 'Image ${image} does not exist.'
                                    fi
                                """
                            }
                        }
                    } else {
                        echo "No old images found matching pattern ${OLD_IMAGE_TAG_PATTERN}"
                    }
                }
            }
        }

        stage('GetCode') {
            steps {
                git branch: 'master', url: 'https://github.com/manoj7894/tomat123.git'
            }
        }

        stage('Build') {
            steps {
                sh "mvn clean package"
                sh "docker build -t ${DOCKER_IMAGE} ."
            }
        }
        stage('OWASP SCAN') {
            steps {
                dependencyCheck additionalArguments: '', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        stage ("Trivy image scan") {
            steps {
                script {
                    sh "trivy image ${DOCKER_IMAGE} > trivy.txt"
                }
            }
        }

        stage('Login') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'Docker_id', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'
                }
            }
        }

        stage('Static Code Analysis') {
            environment {
                SONAR_URL = "http://13.201.185.189:9000"
            }
            steps {
                withCredentials([string(credentialsId: 'sonar_token', variable: 'SONAR_AUTH_TOKEN')]) {
                    sh '''
                        mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=$SONAR_URL
                    '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    def dockerImage = docker.image(DOCKER_IMAGE)
                    dockerImage.push() // Pushes the Docker image to the repository
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        // Configure Git
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        // Check out the repository
                        sh 'git checkout master'

                        // Display the current content of the deployment file for debugging
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        // Update the image tag in deployment.yml
                        sh '''
                            # Use sed to replace the image tag dynamically
                            sed -i "s|image: manoj3003/pipelie-cicd:[^[:space:]]*|image: manoj3003/pipelie-cicd:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        // Check for changes and commit if necessary
                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:master
                            fi
                        '''
                    }
                }
            }
        }
    }

    post {
        always {
            emailext attachLog: true,
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'manojvarmapotthutri@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                attachmentsPattern: 'trivy.txt',
                mimeType: 'text/html'
        }
    }
}


# To deploy the nodejs application we will follow the below script
pipeline {
    agent any
    
    tools {
        nodejs 'node22'
    }

    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/database:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/database:*"  // Pattern to match old images
        GIT_REPO_NAME = "Manipulating"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Manifests/dss.yml"  // Adjust the path if necessary
        SCANNER_HOME = tool 'sonar-scanner'
    }

    stages {
        stage('Cleanup Old Docker Images') {
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${OLD_IMAGE_TAG_PATTERN}'", returnStdout: true).trim()
                    
                    if (oldImages) {
                        oldImages.split('\n').each { image ->
                            if (image != DOCKER_IMAGE) {
                                echo "Attempting to remove old image ${image}"
                                sh """
                                    if docker images -q ${image} > /dev/null 2>&1; then
                                        docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                    else
                                        echo 'Image ${image} does not exist.'
                                    fi
                                """
                            }
                        }
                    } else {
                        echo "No old images found matching pattern ${OLD_IMAGE_TAG_PATTERN}"
                    }
                }
            }
        }
        
        stage('Cleanup Old Trivy Reports') {
            steps {
                script {
                    echo "Cleaning up old Trivy reports..."
                    sh '''
                        rm -f trivy.txt
                        rm -f fs-report.html
                    '''
                }
            }
        }
        
        stage('GetCode') {
            steps {
                git branch: 'main', url: 'https://github.com/manoj7894/Manipulating.git'
            }
        }
        
        stage('Install Package Dependencies') {
            steps {
                sh "npm install"
            }
        }
        
        stage('Check for Tests') {
            steps {
                script {
                    def testScriptExists = sh(script: "grep -q '\"test\":' package.json", returnStatus: true) == 0
                    env.TEST_SCRIPT_EXISTS = testScriptExists ? 'true' : 'false'
                }
            }
        }
        
        /*
        stage('unit test') {
            when {
                expression { env.TEST_SCRIPT_EXISTS == 'true' }
            }
            steps {
                script {
                    try {
                        sh "npm test"
                        currentBuild.result = 'SUCCESS'
                    } catch (Exception e) {
                        echo "Unit tests failed. Continuing with the pipeline."
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        } */
        
        stage('OWASP SCAN') {
            when {
                expression {
                    // Check if pom.xml exists
                    return fileExists('pom.xml')
                }
            }
            steps {
                dependencyCheck additionalArguments: '', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        
        stage("Trivy filesystem scan") {
            steps {
                script {
                    sh "trivy fs --format table -o fs-report.html ."
                }
            }
        }
        
        stage('Build') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker build -t ${DOCKER_IMAGE} ."
                    }
                }
            }
        }
        
        stage("Trivy image scan") {
            steps {
                script {
                    sh "trivy image ${DOCKER_IMAGE} > trivy.txt"
                }
            }
        }
        
        stage("SonarQube") {
            steps {
                withSonarQubeEnv('Sonar_Install') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=Campground \
                    -Dsonar.projectKey=Campground '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        sh 'git checkout main'
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        sh '''
                            sed -i "s|image: manoj3003/database:[^[:space:]]*|image: manoj3003/database:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:main
                            fi
                        '''
                    }
                }
            }
        }
    
    post {
        always {
            emailext attachLog: true,
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'manojvarmapotthutri@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                attachmentsPattern: 'trivy.txt',
                mimeType: 'text/html'
        }
    }
}


# So far we have completed the continuous integration process 
# From now we are going to do continous delivery and continous deployment
# We have to create EKS cluster because we are going to deploy the application by using EKS cluster

# We have to execute the below commands to connect with the cluster after complete the installation.
aws eks --region ap-south-1 describe-cluster --name eks-1 --query cluster.status
aws eks --region ap-south-1 update-kubeconfig --name eks-1
aws eks list-clusters --> To see the cluster
kubectl get nodes

# If we want to deploy the application with ArgoCd through EKS cluster. you have to follow the below steps
kubectl create namespace argocd   --> To create the namespace
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/master/manifests/install.yaml    --> To install argocd
kubectl get all -n argocd   --> To check instalitation
kubectl edit svc argocd-server -n argocd     --> by default it will come with clusterIP. edit and keep load balancer.[After the modify the service it will give load balancer URL then copy that URL and paste in web browser]
kubectl get secret -n argocd   --> To see the secret
kubectl edit secret argocd-initial-admin-secret -n argocd   --> To get the password of argocd and username is admin and you will get password in encryption format. you will use command decrypted the passowrd and paste that password in argocd.

echo MWV1QzFNaElVQ2lJVHdKSA== | base64 --decode  --> To decode the data or decrypt

# After Loginto the Argocd you will deploy the application into Cluster using below video link
         https://youtu.be/JGQI5pkK82w?si=2D32gqfVuXjetLoM

# To use the docker private image for kubernets deployment. we have to create secret using below command
kubectl create secret docker-registry regcred --docker-server=https://index.docker.io/v1/ --docker-username=manoj3003 --docker-password=Varma_3003 --namespace=webapps



# Later to monitor our cluster i have used dynatrace monitor tool. To install the dynatrace one agent in our cluster. i have followed the below video.
       https://youtu.be/GC2JH3DVxwg?si=wvBDIFqUPR6dMbRl

# You have to download dynakube.yml file in dynatrace. If you follow the above video you will get know all the things.

helm install dynatrace-operator oci://public.ecr.aws/dynatrace/dynatrace-operator --create-namespace --namespace dynatrace --atomic

kubectl apply -f dynakube.yaml


# Use the below command to clen the disk space in your terminal
docker system prune -a --volumes

#Remove old logs
sudo find /var/log -type f -name "*.log" -delete









# If you want to deploy the application using CI/CD pipeline through EKS CLuster
-> You have install the plugins in jenkins
   -> Kubernetes
   -> Kuberntes Client API
   -> Kubernetes Credentials
   -> Kubernetes CLI
# Restart the jenkins after install the plugins

# To deploy the application with RBAC
# To connect with Jenkins securely you have to create service account and roles
roles worked on namespaces and cluster role worked on cluster level means work on all the namespaces
persistence volumes cant work on roles level. you deploy below application without having persistence volume ymal scrpit

# Create service account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: webapps

kubectl appl-f name.yml

# Create Role
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: app-role
  namespace: webapps
rules:
  - apiGroups:
        - ""
        - apps
        - autoscaling
        - batch
        - extensions
        - policy
        - rbac.authorization.k8s.io
    resources:
      - pods
      - secrets
      - componentstatuses
      - configmaps
      - daemonsets
      - deployments
      - events
      - endpoints
      - horizontalpodautoscalers
      - ingress
      - jobs
      - limitranges
      - namespaces
      - nodes
      - pods
      - persistentvolumes
      - persistentvolumeclaims
      - resourcequotas
      - replicasets
      - replicationcontrollers
      - serviceaccounts
      - services
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

kubectl appl-f name.yml


# Bind the role to service account
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-rolebinding
  namespace: webapps 
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: app-role 
subjects:
- namespace: webapps 
  kind: ServiceAccount
  name: jenkins 

kubectl appl-f name.yml


# Create the secret token
apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: mysecretname
  annotations:
    kubernetes.io/service-account.name: Jenkins

kubectl appl-f name.yml -n webapps
kuebctl get secret -n webapps
kubectl describe secret <secretname> -n webapps
# Copy the token and go the Jenkins credentials and selelt secret text in kind and copy the token and id some is name.


pipeline {
    agent any
    
    tools {
        nodejs 'node22'
    }

    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/database:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/database:*"  // Pattern to match old images
        GIT_REPO_NAME = "swiggy-nodejs-devops-project"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Kubernetes/deployment.yml"  // Adjust the path if necessary
        SCANNER_HOME = tool 'sonar-scanner'
    }

    stages {
        stage('Cleanup Old Docker Images') {
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${OLD_IMAGE_TAG_PATTERN}'", returnStdout: true).trim()
                    
                    if (oldImages) {
                        oldImages.split('\n').each { image ->
                            if (image != DOCKER_IMAGE) {
                                echo "Attempting to remove old image ${image}"
                                sh """
                                    if docker images -q ${image} > /dev/null 2>&1; then
                                        docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                    else
                                        echo 'Image ${image} does not exist.'
                                    fi
                                """
                            }
                        }
                    } else {
                        echo "No old images found matching pattern ${OLD_IMAGE_TAG_PATTERN}"
                    }
                }
            }
        }
        stage('Cleanup Old Trivy Reports') {
            steps {
                script {
                    echo "Cleaning up old Trivy reports..."
                    sh '''
                        rm -f trivy.txt
                        rm -f fs-report.html
                    '''
                }
            }
        }
        
        stage('GetCode') {
            steps {
                git branch: 'main', url: 'https://github.com/manoj7894/swiggy-nodejs-devops-project.git'
            }
        }
        
        stage('Install Package Dependencies') {
            steps {
                sh "npm install"
            }
        }
        
        stage('Check for Tests') {
            steps {
                script {
                    def testScriptExists = sh(script: "grep -q '\"test\":' package.json", returnStatus: true) == 0
                    env.TEST_SCRIPT_EXISTS = testScriptExists ? 'true' : 'false'
                }
            }
        }
        
        /*
        stage('unit test') {
            when {
                expression { env.TEST_SCRIPT_EXISTS == 'true' }
            }
            steps {
                script {
                    try {
                        sh "npm test"
                        currentBuild.result = 'SUCCESS'
                    } catch (Exception e) {
                        echo "Unit tests failed. Continuing with the pipeline."
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        } */
        
        stage('OWASP SCAN') {
            when {
                expression {
                    // Check if pom.xml exists
                    return fileExists('pom.xml')
                }
            }
            steps {
                dependencyCheck additionalArguments: '', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        
        stage("Trivy filesystem scan") {
            steps {
                script {
                    sh "trivy fs --format table -o fs-report.html ."
                }
            }
        }
        
        stage('Build') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker build -t ${DOCKER_IMAGE} ."
                    }
                }
            }
        }
        
        stage("Trivy image scan") {
            steps {
                script {
                    sh "trivy image ${DOCKER_IMAGE} > trivy.txt"
                }
            }
        }
        
        stage("SonarQube") {
            steps {
                withSonarQubeEnv('Sonar_Install') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=Campground \
                    -Dsonar.projectKey=Campground '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        sh 'git checkout main'
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        sh '''
                            sed -i "s|image: manoj3003/database:[^[:space:]]*|image: manoj3003/database:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:main
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('K8S-Deploy') {
            steps {
                withKubeConfig(caCertificate: '', clusterName: ' eks-1', contextName: '', credentialsId: 'k8-token', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://05FF96831A57B61D6882E866196EB072.sk1.ap-south-1.eks.amazonaws.com') {
                sh "kubectl apply -f Kubernetes/deployment.yml"
                sh "kubectl apply -f Kubernetes/service.yml"
                sleep 20
                }
            }
        }
        
         stage('Verify the Deployment') {
            steps {
                withKubeConfig(caCertificate: '', clusterName: ' eks-1', contextName: '', credentialsId: 'k8-token', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://05FF96831A57B61D6882E866196EB072.sk1.ap-south-1.eks.amazonaws.com') {
                sh "kubectl get pods"
                sh "kubectl get svc"
                }
            }
        }
    }
    
    

    post {
        always {
            emailext attachLog: true,
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'manojvarmapotthutri@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                attachmentsPattern: 'trivy.txt',
                mimeType: 'text/html'
        }
    }
}



# We can deploy application with having persistence volume application
# Crate service account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: webapps

# create Cluster role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: jenkins-cluster-role
rules:
  - apiGroups:
        - ""
        - apps
        - autoscaling
        - batch
        - extensions
        - policy
        - rbac.authorization.k8s.io
    resources:
      - pods
      - secrets
      - componentstatuses
      - configmaps
      - daemonsets
      - deployments
      - events
      - endpoints
      - horizontalpodautoscalers
      - ingress
      - jobs
      - limitranges
      - namespaces
      - nodes
      - pods
      - persistentvolumes
      - persistentvolumeclaims
      - resourcequotas
      - replicasets
      - replicationcontrollers
      - serviceaccounts
      - services
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

# Bind the service and cluster role
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: jenkins-cluster-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: jenkins-cluster-role
subjects:
- namespace: webapps
  kind: ServiceAccount
  name: jenkins


# Create the secret token based on service account
apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: mysecretname
  annotations:
    kubernetes.io/service-account.name: jenkins

kubectl apply -f secret.yml -n webapps
# Copy the token and go the Jenkins credentials and selelt secret text in kind and copy the token and id some is name

pipeline {
    agent any
    
    tools {
        nodejs 'node22'
    }

    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/database:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/database:*"  // Pattern to match old images
        GIT_REPO_NAME = "Manipulating"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Manifests/dss.yml"  // Adjust the path if necessary
        SCANNER_HOME = tool 'sonar-scanner'
    }

    stages {
        stage('Cleanup Old Docker Images') {
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${OLD_IMAGE_TAG_PATTERN}'", returnStdout: true).trim()
                    
                    if (oldImages) {
                        oldImages.split('\n').each { image ->
                            if (image != DOCKER_IMAGE) {
                                echo "Attempting to remove old image ${image}"
                                sh """
                                    if docker images -q ${image} > /dev/null 2>&1; then
                                        docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                    else
                                        echo 'Image ${image} does not exist.'
                                    fi
                                """
                            }
                        }
                    } else {
                        echo "No old images found matching pattern ${OLD_IMAGE_TAG_PATTERN}"
                    }
                }
            }
        }
        stage('Cleanup Old Trivy Reports') {
            steps {
                script {
                    echo "Cleaning up old Trivy reports..."
                    sh '''
                        rm -f trivy.txt
                        rm -f fs-report.html
                    '''
                }
            }
        }
        
        stage('GetCode') {
            steps {
                git branch: 'main', url: 'https://github.com/manoj7894/Manipulating.git'
            }
        }
        
        stage('Install Package Dependencies') {
            steps {
                sh "npm install"
            }
        }
        
        stage('Check for Tests') {
            steps {
                script {
                    def testScriptExists = sh(script: "grep -q '\"test\":' package.json", returnStatus: true) == 0
                    env.TEST_SCRIPT_EXISTS = testScriptExists ? 'true' : 'false'
                }
            }
        }
        
        /*
        stage('unit test') {
            when {
                expression { env.TEST_SCRIPT_EXISTS == 'true' }
            }
            steps {
                script {
                    try {
                        sh "npm test"
                        currentBuild.result = 'SUCCESS'
                    } catch (Exception e) {
                        echo "Unit tests failed. Continuing with the pipeline."
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        } */
        
        stage('OWASP SCAN') {
            when {
                expression {
                    // Check if pom.xml exists
                    return fileExists('pom.xml')
                }
            }
            steps {
                dependencyCheck additionalArguments: '', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        
        stage("Trivy filesystem scan") {
            steps {
                script {
                    sh "trivy fs --format table -o fs-report.html ."
                }
            }
        }
        
        stage('Build') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker build -t ${DOCKER_IMAGE} ."
                    }
                }
            }
        }
        
        stage("Trivy image scan") {
            steps {
                script {
                    sh "trivy image ${DOCKER_IMAGE} > trivy.txt"
                }
            }
        }
        
        stage("SonarQube") {
            steps {
                withSonarQubeEnv('Sonar_Install') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=Campground \
                    -Dsonar.projectKey=Campground '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        sh 'git checkout main'
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        sh '''
                            sed -i "s|image: manoj3003/database:[^[:space:]]*|image: manoj3003/database:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:main
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('K8S-Deploy') {
            steps {
                withKubeConfig(caCertificate: '', clusterName: ' eks-1', contextName: '', credentialsId: 'K8S-Token', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://05FF96831A57B61D6882E866196EB072.sk1.ap-south-1.eks.amazonaws.com') {
                sh "kubectl apply -f Manifests/pv.yml"
                sh "kubectl apply -f Manifests/pvc.yml"
                sh "kubectl apply -f Manifests/secret.yml"
                sh "kubectl apply -f Manifests/service.yml"
                sh "kubectl apply -f Manifests/dss.yml"
                sleep 20
                }
            }
        }
        
         stage('Verify the Deployment') {
            steps {
                withKubeConfig(caCertificate: '', clusterName: ' eks-1', contextName: '', credentialsId: 'K8S-Token', namespace: 'webapps', restrictKubeConfigAccess: false, serverUrl: 'https://05FF96831A57B61D6882E866196EB072.sk1.ap-south-1.eks.amazonaws.com') {
                sh "kubectl get pods"
                sh "kubectl get svc"
                sh "kubectl get pv"
                sh "kubectl get pvc"
                }
            }
        }
    }
    
    

    post {
        always {
            emailext attachLog: true,
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'manojvarmapotthutri@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                attachmentsPattern: 'trivy.txt',
                mimeType: 'text/html'
        }
    }
}








# To deploy the application directly with having any RBAC
# You have to copy the config file data into normal file and keep file on desktop
# Create the credentials with secret text, choose the file which you copied on desktop and give id name
# You will install the two plugins
   -> AWS Steps
   -> AWS Credentials
# Create the credentials and choose the AWS and give access and secret key, Id name
 

pipeline {
    agent any
    
    tools {
        nodejs 'node22'
    }

    environment {
        DOCKERHUB_CREDENTIALS = credentials('Docker_id')
        DOCKER_IMAGE = "manoj3003/database:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/database:*"  // Pattern to match old images
        GIT_REPO_NAME = "Manipulating"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Manifests/dss.yml"  // Adjust the path if necessary
        SCANNER_HOME = tool 'sonar-scanner'
        AWS_CREDENTIALS = credentials('aws-credentials-id')
        KUBECONFIG = credentials('config_token')  // Adjust if necessary
    }

    stages {
        stage('Cleanup Old Docker Images') {
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${OLD_IMAGE_TAG_PATTERN}'", returnStdout: true).trim()
                    
                    if (oldImages) {
                        oldImages.split('\n').each { image ->
                            if (image != DOCKER_IMAGE) {
                                echo "Attempting to remove old image ${image}"
                                sh """
                                    if docker images -q ${image} > /dev/null 2>&1; then
                                        docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                    else
                                        echo 'Image ${image} does not exist.'
                                    fi
                                """
                            }
                        }
                    } else {
                        echo "No old images found matching pattern ${OLD_IMAGE_TAG_PATTERN}"
                    }
                }
            }
        }
        
        stage('Cleanup Old Trivy Reports') {
            steps {
                script {
                    echo "Cleaning up old Trivy reports..."
                    sh '''
                        rm -f trivy.txt
                        rm -f fs-report.html
                    '''
                }
            }
        }
        
        stage('GetCode') {
            steps {
                git branch: 'main', url: 'https://github.com/manoj7894/Manipulating.git'
            }
        }
        
        stage('Install Package Dependencies') {
            steps {
                sh "npm install"
            }
        }
        
        stage('Check for Tests') {
            steps {
                script {
                    def testScriptExists = sh(script: "grep -q '\"test\":' package.json", returnStatus: true) == 0
                    env.TEST_SCRIPT_EXISTS = testScriptExists ? 'true' : 'false'
                }
            }
        }
        
        /*
        stage('unit test') {
            when {
                expression { env.TEST_SCRIPT_EXISTS == 'true' }
            }
            steps {
                script {
                    try {
                        sh "npm test"
                        currentBuild.result = 'SUCCESS'
                    } catch (Exception e) {
                        echo "Unit tests failed. Continuing with the pipeline."
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        } */
        
        stage('OWASP SCAN') {
            when {
                expression {
                    // Check if pom.xml exists
                    return fileExists('pom.xml')
                }
            }
            steps {
                dependencyCheck additionalArguments: '', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        
        stage("Trivy filesystem scan") {
            steps {
                script {
                    sh "trivy fs --format table -o fs-report.html ."
                }
            }
        }
        
        stage('Build') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker build -t ${DOCKER_IMAGE} ."
                    }
                }
            }
        }
        
        stage("Trivy image scan") {
            steps {
                script {
                    sh "trivy image ${DOCKER_IMAGE} > trivy.txt"
                }
            }
        }
        
        stage("SonarQube") {
            steps {
                withSonarQubeEnv('Sonar_Install') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=Campground \
                    -Dsonar.projectKey=Campground '''
                }
            }
        }

        stage('Push') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }

        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''

                        sh 'git checkout main'
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'

                        sh '''
                            sed -i "s|image: manoj3003/database:[^[:space:]]*|image: manoj3003/database:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''

                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:main
                            fi
                        '''
                    }
                }
            }
        }
        
        // stage('Create Namespace') {
        //     steps {
        //         script {
        //             withCredentials([file(credentialsId: 'config_token', variable: 'KUBECONFIG_FILE')]) {
        //                 sh '''
        //                     export KUBECONFIG=$KUBECONFIG_FILE
        //                     kubectl get namespace webapps || kubectl create namespace webapps
        //                 '''
        //             }
        //         }
        //     }
        // }
        
        stage('Deploy') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'config_token', variable: 'KUBECONFIG_FILE')]) {
                        sh '''
                            export KUBECONFIG=$KUBECONFIG_FILE
                            kubectl apply -f Manifests/pv.yml
                            kubectl apply -f Manifests/pvc.yml
                            kubectl apply -f Manifests/secret.yml
                            kubectl apply -f Manifests/service.yml
                            kubectl apply -f Manifests/dss.yml
                        '''
                        sleep 20
                    }
                }
            }
        }
        
        stage('Verify the Deployment') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'config_token', variable: 'KUBECONFIG_FILE')]) {
                        sh '''
                            export KUBECONFIG=$KUBECONFIG_FILE
                            kubectl get pods
                            kubectl get svc
                            kubectl get pv
                            kubectl get pvc
                        '''
                    }
                }
            }
        }
    }
    
    post {
        always {
            emailext attachLog: true,
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'manojvarmapotthutri@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                attachmentsPattern: 'trivy.txt',
                mimeType: 'text/html'
        }
    }
}







# Final upto CI



pipeline {
    agent any

    tools {
        nodejs 'node22'
    }

    environment {
        DOCKER_IMAGE = "manoj3003/database:${BUILD_NUMBER}"
        OLD_IMAGE_TAG_PATTERN = "manoj3003/database:*"  // Pattern to match old images
        GIT_REPO_NAME = "Manipulating"
        GIT_USER_NAME = "manoj7894"
        DEPLOYMENT_FILE_PATH = "Manifests/dss.yml"  // Adjust the path if necessary
        SCANNER_HOME = tool 'sonar-scanner'
        WORKSPACE_BASE = "/var/lib/jenkins/workspace" // Set this to the base path of your Jenkins workspaces
    }

    stages {
         stage('Cleanup Old Workspaces') {
            steps {
                script {
                    echo "Cleaning up all workspaces except the current build..."

                    // Get the current workspace directory
                    def currentWorkspaceDir = env.WORKSPACE

                    // Use a shell script to clean up old workspaces
                    sh '''
                        #!/bin/bash

                        # Enable diagnostics
                        set -x
                        echo "Current workspace: ${currentWorkspaceDir}"

                        # The directory we need to preserve
                        PRESERVE_DIR="${currentWorkspaceDir}"

                        # Base path for Jenkins workspaces
                        BASE_PATH="${WORKSPACE_BASE}"

                        # Ensure that the current build workspace directory exists
                        if [ ! -d "$PRESERVE_DIR" ]; then
                            echo "Current workspace directory $PRESERVE_DIR does not exist. Skipping cleanup."
                            exit 0
                        fi

                        # Find and delete directories excluding the current build directory
                        for dir in $(find $BASE_PATH -maxdepth 1 -type d ! -path "$PRESERVE_DIR" ! -path "$BASE_PATH"); do
                            echo "Deleting old workspace: $dir"
                            rm -rf "$dir"
                        done
                    '''
                }
            }
        }

        stage('Check Old Docker Images') {
            steps {
                script {
                    echo "Checking for old Docker images..."
                    
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '^manoj3003/database:' || true", returnStdout: true).trim()
                    echo "Old images found: ${oldImages}"
                    
                    if (oldImages) {
                        env.OLD_IMAGES_EXIST = 'true'
                    } else {
                        echo "No old images found."
                        env.OLD_IMAGES_EXIST = 'false'
                    }
                }
            }
        }

        stage('Cleanup Old Docker Images') {
            when {
                expression { env.OLD_IMAGES_EXIST == 'true' }
            }
            steps {
                script {
                    echo "Cleaning up old Docker images..."
                    
                    def oldImages = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '^manoj3003/database:' || true", returnStdout: true).trim()
                    echo "Old images found for cleanup: ${oldImages}"
                    
                    if (oldImages) {
                        def imagesToRemove = oldImages.split('\n').findAll { image ->
                            image != DOCKER_IMAGE
                        }
                        
                        if (imagesToRemove) {
                            imagesToRemove.each { image ->
                                echo "Attempting to remove old image ${image}"
                                try {
                                    sh """
                                        if docker images -q ${image} > /dev/null 2>&1; then
                                            docker rmi -f ${image} || echo 'Failed to remove image ${image} - might be in use or other error.'
                                        else
                                            echo 'Image ${image} does not exist.'
                                        fi
                                    """
                                } catch (Exception e) {
                                    echo "Error while attempting to remove image ${image}: ${e.getMessage()}"
                                }
                            }
                        } else {
                            echo "No old images to remove."
                        }
                    } else {
                        echo "No old images found matching pattern 'manoj3003/database:'"
                    }
                }
            }
        }
        
        stage('Cleanup Old Trivy Reports') {
            steps {
                script {
                    echo "Cleaning up old Trivy reports..."
                    sh '''
                        rm -f trivy.txt
                        rm -f fs-report.html
                    '''
                }
            }
        }
        
        stage('Get Code') {
            steps {
                git branch: 'main', url: 'https://github.com/manoj7894/Manipulating.git'
            }
        }
        
        stage('Install Package Dependencies') {
            steps {
                sh "npm install"
            }
        }
        
        stage('Check for Tests') {
            steps {
                script {
                    def testScriptExists = sh(script: "grep -q '\"test\":' package.json", returnStatus: true) == 0
                    env.TEST_SCRIPT_EXISTS = testScriptExists ? 'true' : 'false'
                }
            }
        }
        
        /*
        stage('Unit Test') {
            when {
                expression { env.TEST_SCRIPT_EXISTS == 'true' }
            }
            steps {
                script {
                    try {
                        sh "npm test"
                        currentBuild.result = 'SUCCESS'
                    } catch (Exception e) {
                        echo "Unit tests failed. Continuing with the pipeline."
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        } */
        
        stage('OWASP Scan') {
            when {
                expression {
                    fileExists('pom.xml')
                }
            }
            steps {
                dependencyCheck additionalArguments: '', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        
        stage('Trivy Filesystem Scan') {
            steps {
                script {
                    sh "trivy fs --format table -o fs-report.html ."
                }
            }
        }
        
        stage('Build') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker build -t ${DOCKER_IMAGE} ."
                    }
                }
            }
        }
        
        stage('Trivy Image Scan') {
            steps {
                script {
                    sh "trivy image ${DOCKER_IMAGE} > trivy.txt"
                }
            }
        }
        
        stage('SonarQube') {
            steps {
                withSonarQubeEnv('Sonar_Install') {
                    sh '''$SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=Campground \
                    -Dsonar.projectKey=Campground \
                    -Dsonar.host.url=http://65.0.180.233:9000'''
                }
            }
        }
        
        stage('Push') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'Docker_id', toolName: 'Docker') {
                        sh "docker push ${DOCKER_IMAGE}"
                    }
                }
            }
        }
        
        stage('Update Deployment File') {
            steps {
                withCredentials([string(credentialsId: 'github_id', variable: 'GITHUB_TOKEN')]) {
                    script {
                        sh '''
                            git config user.email "manojvarmapotthuri3003@gmail.com"
                            git config user.name "Manojvarma Potthuri"
                        '''
                        
                        sh 'git checkout main'
                        sh 'cat ${DEPLOYMENT_FILE_PATH}'
                        
                        sh '''
                            sed -i "s|image: manoj3003/database:[^[:space:]]*|image: manoj3003/database:${BUILD_NUMBER}|g" ${DEPLOYMENT_FILE_PATH}
                        '''
                        
                        sh '''
                            if git diff --quiet; then
                                echo "No changes detected in ${DEPLOYMENT_FILE_PATH}"
                            else
                                git add ${DEPLOYMENT_FILE_PATH}
                                git commit -m "Update deployment image to version ${BUILD_NUMBER}"
                                git push -f https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME}.git HEAD:main
                            fi
                        '''
                    }
                }
            }
        }
    }
    
    post {
        always {
            emailext attachLog: true,
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'manojvarmapotthutri@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                attachmentsPattern: 'trivy.txt',
                mimeType: 'text/html'
        }
    }
}















# To deploy the application into tomcat server you have to follow the below steps
-> First you will download the tomcat using below steps
##################----INSTALL TOMCAT----##################
cd /opt
you will get below link from apache tomcat website
https://tomcat.apache.org/download-90.cgi  click tar.gz in core
sudo wget https://archive.apache.org/dist/tomcat/tomcat-9/v9.0.65/bin/apache-tomcat-9.0.65.tar.gz
sudo tar -xvf apache-tomcat-9.0.65.tar.gz

cd /opt/apache-tomcat-9.0.65/conf
sudo vi tomcat-users.xml
# ---add-below-line at the end (2nd-last line)----
# <user username="admin" password="admin1234" roles="admin-gui, manager-gui"/>

sudo ln -s /opt/apache-tomcat-9.0.65/bin/startup.sh /usr/bin/startTomcat
sudo ln -s /opt/apache-tomcat-9.0.65/bin/shutdown.sh /usr/bin/stopTomcat

sudo vi /opt/apache-tomcat-9.0.65/webapps/manager/META-INF/context.xml

comment:
<!-- Valve className="org.apache.catalina.valves.RemoteAddrValve"
  allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /> -->

sudo vi /opt/apache-tomcat-9.0.65/webapps/host-manager/META-INF/context.xml

comment:
<!-- Valve className="org.apache.catalina.valves.RemoteAddrValve"
  allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /> -->


cd /opt/apache-tomcat-9.0.65/bin
sh startup.sh

-> You will install the Deployment container plugin in jenkins
-> you will tomcat username and password in your credentials
-> You will execute the below script



pipeline {
    agent any

    environment {
        SCANNER_HOME = tool 'sonar-scanner'
        WORKSPACE_BASE = "/var/lib/jenkins/workspace" // Set this to the base path of your Jenkins workspaces
    }

    stages {
        /*
         stage('Cleanup Old Workspaces') {
            steps {
                script {
                    echo "Cleaning up all workspaces except the current build..."

                    // Get the current workspace directory
                    def currentWorkspaceDir = env.WORKSPACE

                    // Use a shell script to clean up old workspaces
                    sh '''
                        #!/bin/bash

                        # Enable diagnostics
                        set -x
                        echo "Current workspace: ${currentWorkspaceDir}"

                        # The directory we need to preserve
                        PRESERVE_DIR="${currentWorkspaceDir}"

                        # Base path for Jenkins workspaces
                        BASE_PATH="${WORKSPACE_BASE}"

                        # Ensure that the current build workspace directory exists
                        if [ ! -d "$PRESERVE_DIR" ]; then
                            echo "Current workspace directory $PRESERVE_DIR does not exist. Skipping cleanup."
                            exit 0
                        fi

                        # Find and delete directories excluding the current build directory
                        for dir in $(find $BASE_PATH -maxdepth 1 -type d ! -path "$PRESERVE_DIR" ! -path "$BASE_PATH"); do
                            echo "Deleting old workspace: $dir"
                            rm -rf "$dir"
                        done
                    '''
                }
            }
        } */
        
        stage('Get Code') {
            steps {
                git branch: 'main', url: 'https://github.com/manoj7894/java-tomcat.git'
            }
        }
        
        stage("Compile"){
            steps{
                sh "mvn clean compile"
            }
        }
        
        stage("Test Cases"){
            steps{
                sh "mvn test"
            }
        }
        
        // stage('SonarQube') {
        //     steps {
        //         withSonarQubeEnv('Sonar_Install') {
        //             sh '''$SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=Campground \
        //             -Dsonar.projectKey=Campground \
        //             -Dsonar.host.url=http://13.232.72.13:9000'''
        //         }
        //     }
        // }
        
        stage('SonarQube'){
            steps{
                withSonarQubeEnv('Sonar_Install') {
                    sh ''' $SCANNER_HOME/bin/sonar-scanner -Dsonar.projectName=Petclinic \
                    -Dsonar.java.binaries=. \
                    -Dsonar.projectKey=Sample \
                    -Dsonar.host.url=http://13.233.77.222:9000'''
    
                }
            }
        }
        
        stage('OWASP Scan') {
            when {
                expression {
                    fileExists('pom.xml')
                }
            }
            steps {
                dependencyCheck additionalArguments: '', odcInstallation: 'DP-Check'
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
            }
        }
        
        // stage("OWASP Dependency Check"){
        //     steps{
        //         dependencyCheck additionalArguments: '--scan ./ --format HTML ', odcInstallation: 'DP-Check'
        //         dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
        //     }
        // }
        
        stage('Trivy Filesystem Scan') {
            steps {
                script {
                    sh "trivy fs --format table -o fs-report.html ."
                }
            }
        }
        
        stage("Build"){
            steps{
                sh " mvn clean install"
            }
        }
        
        stage('Deploy to tomcat server') {
            steps{                                 
                deploy adapters: [tomcat9(credentialsId: 'tomcat_id', path: '', url: 'http://13.233.77.222:9090/')], contextPath: 'sample-java', war: '**/*.war'
            }
        }
    }
    
    post {
        always {
            emailext attachLog: true,
                subject: "Pipeline Status: ${BUILD_NUMBER}",
                body: '''<html>
                           <body>
                              <p>Build Status: ${BUILD_STATUS}</p>
                              <p>Build Number: ${BUILD_NUMBER}</p>
                              <p>Check the <a href="${BUILD_URL}">console output</a>.</p>
                           </body>
                        </html>''',
                to: 'manojvarmapotthutri@gmail.com',
                from: 'jenkins@example.com',
                replyTo: 'jenkins@example.com',
                attachmentsPattern: 'trivy.txt',
                mimeType: 'text/html'
        }
    }
}





# If you want to run the jobs on docker agent 
-> Click manage jenkins, click nodes, click new node, give name, click permanent, click docker and give laber docker-agent. 
-> root directory means create one directory in terminal and give path at that place.
-> follow video in phone to configure the reset of the steps.

keep like this 
  agent {
        label 'docker-agent'
    }
