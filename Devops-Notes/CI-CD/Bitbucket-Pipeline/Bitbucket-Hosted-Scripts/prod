image: node:20

pipelines:
  branches:
    release/production:
      # ------------------------------
      # 1ï¸âƒ£ Build, Test, and Scan (Test)
      # ------------------------------
      - step:
          name: Build, Test, and Scan Source-Code (Production)
          deployment: Production-Test
          services:
            - docker
          caches:
            - node
          script:
            - |
              echo "SonarQube Host: ${SONAR_HOST_URL}"
              echo "Project Key: ${SONAR_PROJECT_KEY}"
              echo "Token Length: ${#SONARQUBE_TOKEN}"

              echo "Environment variables loaded."
              apt-get update && apt-get install -y curl unzip jq mutt

              npm install
              npm run build --if-present
              npm test --if-present

              curl -sfL https://github.com/aquasecurity/trivy/releases/download/v0.39.0/trivy_0.39.0_Linux-64bit.deb -o trivy.deb
              dpkg -i trivy.deb

              export TRIVY_CACHE_DIR=/tmp/trivy-cache
              mkdir -p $TRIVY_CACHE_DIR

              trivy fs --cache-dir $TRIVY_CACHE_DIR --format table -o fs-report.html .

              docker build -t "$DOCKER_IMAGE_NAME" .

              trivy image --cache-dir $TRIVY_CACHE_DIR --format table -o image.html "$DOCKER_IMAGE_NAME"

              wget -O sonar-scanner.zip https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip
              unzip sonar-scanner.zip
              export PATH=$PATH:$(pwd)/sonar-scanner-4.8.0.2856-linux/bin

              sonar-scanner -v

              sonar-scanner -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
                            -Dsonar.host.url="${SONAR_HOST_URL}" \
                            -Dsonar.login="${SONARQUBE_TOKEN}"

              docker save -o image.tar "$DOCKER_IMAGE_NAME:latest"

              mkdir -p artifacts
              cp fs-report.html artifacts/
              cp image.html artifacts/
              mv image.tar artifacts/
              tar -cvf artifacts.tar artifacts/

              SMTP_SERVER="$SMTP_SERVER"
              SMTP_PORT="587"
              SMTP_USER="$SMTP_USER"
              SMTP_PASS="$SMTP_PASS"
              TO_EMAIL="$TO_EMAIL"
              FROM_EMAIL="$FROM_EMAIL"
              SUBJECT="ðŸš€ Approval Required: Deploy to Stagging"
              BODY="Hello Team,\n\nThe uat deployment for branch 'uat' is complete.\n\nâš ï¸ Please approve the Stagging deployment:\n\nðŸ”— Bitbucket Pipeline: https://bitbucket.org/workspace/repo/pipelines/\n\nThank you for your prompt approval."

              echo -e "$BODY" | mutt -s "$SUBJECT" \
                -e "set from=\"$FROM_EMAIL\"" \
                -e "set smtp_url=\"smtp://$SMTP_USER:$SMTP_PASS@$SMTP_SERVER:$SMTP_PORT/\"" \
                -e "set smtp_pass=\"$SMTP_PASS\"" \
                -e "set ssl_starttls=yes" \
                -e "set ssl_force_tls=yes" \
                -a "artifacts/fs-report.html" \
                -a "artifacts/image.html" \
                -- "$TO_EMAIL"

              echo "ðŸ“§ Approval request for Stagging deployment sent to ${TO_EMAIL}"
          artifacts:
            - artifacts/*

      # ------------------------------
      # 2ï¸âƒ£ Approval for Stagging Deployment
      # ------------------------------
      - step:
          name: Approval for Production Deployment
          deployment: Production-Approval
          trigger: manual
          script:
            - echo "â³ Waiting for approval before deploying to Stagging..."
            - echo "âœ… Please approve the deployment manually in Bitbucket Pipelines UI."

      # ------------------------------
      # 3ï¸âƒ£ Deploy for Stagging Deployment
      # ------------------------------
      - step:
          name: Deploy to Production
          deployment: Production-Deployment
          services:
            - docker
          script:
            - |
              apt-get update && apt-get install -y mutt awscli

              aws configure set aws_access_key_id "$AWS_ACCESS_KEY_ID"
              aws configure set aws_secret_access_key "$AWS_SECRET_ACCESS_KEY"
              aws configure set region "$AWS_REGION"

              export ECR_REPO_NAME=$(echo "$ECR_REPO_NAME" | tr -d '[:space:]' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]//g')
              echo "âœ… Final ECR Repository Name: '${ECR_REPO_NAME}'"

              echo "ðŸ” Checking if ECR repository exists..."
              if ! aws ecr describe-repositories --repository-names "$ECR_REPO_NAME" --region "$AWS_REGION" > /dev/null 2>&1; then
                echo "ðŸš€ Creating ECR repository: $ECR_REPO_NAME"
                aws ecr create-repository --repository-name "$ECR_REPO_NAME" --region "$AWS_REGION"
              else
                echo "âœ… ECR repository already exists."
              fi

              aws ecr get-login-password --region "$AWS_REGION" | \
                docker login --username AWS --password-stdin "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"

              docker load -i artifacts/image.tar

              export IMAGE_TAG=$(echo "$IMAGE_TAG" | tr -d '[:space:]')
              echo "ðŸ”„ Tagging Docker Image..."
              docker tag "$DOCKER_IMAGE_NAME:latest" "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO_NAME:$IMAGE_TAG"

              docker push "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPO_NAME:$IMAGE_TAG"

              docker system prune -af || true
              docker volume prune -f

              SMTP_SERVER="$SMTP_SERVER"
              SMTP_PORT="$SMTP_PORT"
              SMTP_USER="$SMTP_USER"
              SMTP_PASS="$SMTP_PASS"
              TO_EMAIL="$TO_EMAIL"
              FROM_EMAIL="$FROM_EMAIL"
              SUBJECT="ðŸš€ Stagging Deployment Complete"
              BODY="Hello Team,\n\nThe Stagging deployment for branch 'staging' has been successfully completed and the Stagging deployment is now live.\n\nðŸ”— Bitbucket Pipeline: https://bitbucket.org/workspace/repo/pipelines/\n\nThank you for your support.\n\nBest Regards,\nThe DevOps Team."

              echo -e "$BODY" | mutt -s "$SUBJECT" \
                -e "set from=\"$FROM_EMAIL\"" \
                -e "set smtp_url=\"smtp://$SMTP_USER:$SMTP_PASS@$SMTP_SERVER:$SMTP_PORT/\"" \
                -e "set smtp_pass=\"$SMTP_PASS\"" \
                -e "set ssl_starttls=yes" \
                -e "set ssl_force_tls=yes" \
                -- "$TO_EMAIL"

              echo "ðŸ“§ Stagging deployment complete notification sent to ${TO_EMAIL}"
